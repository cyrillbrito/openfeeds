# URL Slugs for Feeds & Articles

**Date:** 2026-02-21
**Status:** Shelved — prototyped, reverted. Complexity not justified by cosmetic benefit.

## Why (Original Motivation)

1. **Pretty URLs** — `/feeds/the-verge` instead of `/feeds/01935a2b-...`
2. **AI-friendly identifiers** — MCP clients reference entities by human-readable slug instead of opaque UUIDs

## Why It Was Shelved

The complexity-to-value ratio was poor:

- **Permanent dual-lookup** — Every route and API endpoint that resolves a feed or article needs slug-vs-UUID detection. This isn't transitional: because the client creates entities optimistically (before the server generates the slug via Electric sync), every link component must use `slug ?? id` fallback forever.
- **Retry logic everywhere** — Every insert that generates a slug needs collision-retry loops. During the prototype, this logic was duplicated across 4 locations (shared helper, article creation, feed sync, backfill script) instead of being centralized — and centralizing it is awkward because each call site needs different `.returning()` shapes.
- **Large surface area** — Every route, every link component, every API endpoint, every MCP tool needs updating. The prototype missed 4 out of ~10 required locations on the first pass.
- **MCP argument is weak** — LLMs work fine with UUIDs. They parrot back whatever identifier you give them.
- **No SEO benefit** — This is an app, not a blog. Users rarely look at the URL bar.

If pretty URLs become important later, consider a shorter approach like nanoid (no title dependency, no stopwords, no collision retries).

## Design Decisions (Reference)

These decisions were validated during the prototype and can be reused if revisiting.

| Decision           | Choice                                                                   | Rationale                                                                                                             |
| ------------------ | ------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------- |
| Entities           | `feeds` and `articles` only                                              | Tags and junction tables don't appear in URLs or MCP                                                                  |
| Generation         | Server-side only                                                         | Client does optimistic inserts; slug arrives via Electric sync                                                        |
| Uniqueness         | Per-user `(user_id, slug)`                                               | Electric shapes filter by user_id; global uniqueness unnecessary                                                      |
| Column type        | `text` (nullable)                                                        | Null until server generates; `slug` package outputs lowercase so `citext` unnecessary                                 |
| NULL uniqueness    | PostgreSQL allows multiple NULLs in unique indexes                       | Feeds start with `slug = NULL` — the `UNIQUE(user_id, slug)` index won't conflict on NULLs, which is correct behavior |
| Max length         | 80 chars                                                                 | Truncated at last `-` (word boundary) before limit; adjustable later                                                  |
| Slug package       | [`slug`](https://www.npmjs.com/package/slug) v11 (33KB, 0 deps)          | ESM, handles unicode transliteration                                                                                  |
| Stopwords          | [`stopword`](https://www.npmjs.com/package/stopword) v3 (fergiemcdowall) | 62 languages (ISO 639-3), tree-shakeable named exports, TypeScript types                                              |
| Stopword threshold | Only remove stopwords for titles > 40 chars                              | Short titles like "The Verge" keep all words since each carries meaning                                               |
| Collision suffix   | UUID tail hex chars                                                      | On conflict: append last 2 hex chars of entity UUID, then 3, then 4 (up to 3 retries). No extra dependency            |
| Route detection    | `z.uuidv7().safeParse()`                                                 | Zod v4 built-in, no custom regex needed                                                                               |

## Schema Changes

Add to `feeds` and `articles` tables in `packages/db/src/schema/schema.ts`:

```ts
slug: text("slug"),
```

Add unique composite indexes:

```ts
// In feeds table builder
uniqueIndex("feeds_slug_idx").on(table.userId, table.slug),

// In articles table builder
uniqueIndex("articles_slug_idx").on(table.userId, table.slug),
```

Migration: `bun generate:migrations -- --name add-slugs`

Add `slug` to domain Zod schemas (`feed.schema.ts`, `article.schema.ts`):

```ts
slug: z.string().nullable().default(null),
```

## Dependencies

```bash
bun add slug -w packages/shared
bun add stopword -w packages/shared
bun add -d @types/stopword -w packages/shared
# @types/slug is also needed as a dev dependency
bun add -d @types/slug -w packages/shared
```

## Implementation Details

### Slug generation — `packages/shared/src/utils/slug.ts`

This is the refined version from the prototype. Key improvement over the spec's original: uses `removeStopwords()` from the `stopword` library (handles edge cases better than manual filtering) and only strips stopwords for titles longer than 40 characters.

```ts
import slugify from 'slug';
import { eng, removeStopwords } from 'stopword';

const DEFAULT_MAX_LENGTH = 80;
const STOPWORD_THRESHOLD = 40;

export function generateSlug(
  title: string,
  stopwords: string[] = eng,
  maxLength = DEFAULT_MAX_LENGTH,
): string {
  const words = title.split(/\s+/);
  const filtered = title.length > STOPWORD_THRESHOLD ? removeStopwords(words, stopwords) : words;
  const raw = slugify(filtered.join(' '));
  return truncateAtWordBoundary(raw, maxLength);
}

function truncateAtWordBoundary(s: string, max: number): string {
  if (s.length <= max) return s;
  const truncated = s.slice(0, max);
  const lastDash = truncated.lastIndexOf('-');
  return lastDash > 0 ? truncated.slice(0, lastDash) : truncated;
}
```

**Edge cases to watch:**

- Returns empty string `""` if the title is all special characters or (for long titles) all stopwords. Callers must guard with `if (slug)`.
- The 40-char threshold is on `title.length` (character count), not word count. A title like `"A B C D E F G H I J K L M"` (many short words, 40+ chars) would have stopwords removed and could shrink significantly.

### Insert-with-retry helper — `packages/domain/src/slug.ts`

Collision handling via progressively longer UUID-tail suffixes. Catches PostgreSQL unique violation (`23505`).

```ts
const UNIQUE_VIOLATION = '23505';
const MAX_RETRIES = 4;

function uuidHex(id: string): string {
  return id.replace(/-/g, '');
}

function slugSuffix(id: string, attempt: number): string {
  if (attempt === 0) return '';
  return `-${uuidHex(id).slice(-(attempt + 1))}`;
}

// Collision suffix progression:
// attempt 0: "the-verge"
// attempt 1: "the-verge-6a"      (last 2 hex chars)
// attempt 2: "the-verge-f6a"     (last 3 hex chars)
// attempt 3: "the-verge-5f6a"    (last 4 hex chars)

export async function insertWithSlug<T extends PgTable>(
  dbOrTx: DbOrTx,
  table: T,
  row: PgInsertValue<T>,
  slug: string,
  id: string,
): Promise<void> {
  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    try {
      await dbOrTx.insert(table).values({ ...row, slug: slug + slugSuffix(id, attempt) });
      return;
    } catch (e: any) {
      if (e?.code !== UNIQUE_VIOLATION || attempt === MAX_RETRIES - 1) throw e;
    }
  }
}

// Same pattern for updates (feed rename, metadata refresh)
export async function updateSlugWithRetry(
  dbOrTx: DbOrTx,
  table: PgTable,
  idColumn: Column,
  id: string,
  slug: string,
  extraWhere?: SQL,
): Promise<void> {
  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    try {
      const where = extraWhere ? and(eq(idColumn, id), extraWhere) : eq(idColumn, id);
      await dbOrTx
        .update(table)
        .set({ slug: slug + slugSuffix(id, attempt) })
        .where(where);
      return;
    } catch (e: any) {
      if (e?.code !== UNIQUE_VIOLATION || attempt === MAX_RETRIES - 1) throw e;
    }
  }
}
```

**Caveat:** The retry catches _any_ `23505` error, not specifically the slug unique index. If a different unique constraint fires (e.g., GUID collision on articles), the code retries slug generation 3 times unnecessarily before throwing. A more robust version would check `e.constraint` matches the slug index name.

### Where slugs get generated

Feeds start with `title: 'Unknown'` and `slug: NULL`. Slug generation happens at these points:

| When                        | Where                                                        | Trigger                                                                |
| --------------------------- | ------------------------------------------------------------ | ---------------------------------------------------------------------- |
| Feed metadata fetch         | `packages/domain/src/feed-details.ts` `updateFeedMetadata()` | Background job after feed creation, replaces "Unknown" with real title |
| Feed rename                 | `packages/domain/src/entities/feed.ts` `updateFeeds()`       | User manually renames a feed                                           |
| Article creation (save URL) | `packages/domain/src/entities/article.ts` `createArticle()`  | User saves an article by URL                                           |
| RSS sync                    | `packages/domain/src/feed-sync.ts` `syncFeedArticles()`      | New articles from RSS feed parsing                                     |

**Not covered:** If an RSS feed updates an article's title after initial sync, the slug won't change. Would need explicit slug regeneration in a future sync-update path.

### Route resolution — `apps/web/src/utils/routing.ts`

```ts
import { z } from 'zod/v4';

export function isUuidParam(param: string): boolean {
  return z.uuidv7().safeParse(param).success;
}
```

Used in route components to decide whether to query by `id` or `slug` column:

```ts
// In a route component
const currentFeed = () => {
  const feeds = feedsQuery() || [];
  const param = feedId();
  if (isUuidParam(param)) {
    return feeds.find((feed) => feed.id === param) || null;
  }
  // Slug match, with id fallback
  return (
    feeds.find((feed) => feed.slug === param) || feeds.find((feed) => feed.id === param) || null
  );
};

// Resolved UUID for queries that need the actual ID
const resolvedFeedId = () => currentFeed()?.id ?? feedId();
```

### Link pattern — all components

```tsx
// slug ?? id — falls back to UUID before Electric syncs the slug
<Link to="/feeds/$feedId" params={{ feedId: feed.slug ?? feed.id }} />
<Link
  to="/articles/$articleId"
  params={{ articleId: article.slug ?? article.id }}
/>
```

### Backfill script — `packages/scripts/src/backfill-slugs.ts`

One-time script to generate slugs for existing data with `slug = NULL`. Processes feeds in one pass, articles in batches of 500. Same collision retry logic.

**Known issue with the prototype:** The script uses offset-based pagination (`LIMIT 500 OFFSET n`). As rows get updated (slug changes from NULL to a value), they stop matching the `WHERE slug IS NULL` filter, causing the offset to skip rows. A cursor-based approach (`WHERE id > $lastId AND slug IS NULL ORDER BY id LIMIT 500`) would be more reliable.

## Full List of Files to Modify

For future reference, these are all the locations that need changes:

**Schema & domain:**

- `packages/db/src/schema/schema.ts` — add `slug` column + unique indexes
- `packages/domain/src/entities/feed.schema.ts` — add `slug` to Zod schema
- `packages/domain/src/entities/article.schema.ts` — add `slug` to Zod schema
- `packages/domain/src/entities/feed.ts` — slug on rename, map in `toApiFeed()`
- `packages/domain/src/entities/article.ts` — slug on create, map in return types
- `packages/domain/src/feed-sync.ts` — slug on article insert during RSS sync
- `packages/domain/src/feed-details.ts` — slug on metadata update
- `packages/domain/src/slug.ts` — shared insert/update retry helpers
- `packages/domain/src/index.ts` — re-export slug helpers
- `packages/shared/src/utils/slug.ts` — `generateSlug()` utility
- `packages/shared/src/utils/index.ts` — re-export slug utility

**Client-side routes (dual-lookup):**

- `apps/web/src/routes/_frame.feeds.$feedId.index.tsx`
- `apps/web/src/routes/_frame.feeds.$feedId.shorts.index.tsx`
- `apps/web/src/routes/_frame.articles.$articleId.tsx`
- `apps/web/src/routes/api/articles/$articleId/audio.ts`
- `apps/web/src/utils/routing.ts` — `isUuidParam()` helper

**Client-side links (`slug ?? id` pattern):**

- `apps/web/src/components/ArticleCard.tsx`
- `apps/web/src/components/ShortsViewer.tsx`
- `apps/web/src/routes/_frame.feeds.index.tsx`
- Sidebar feed links (if applicable)

**MCP tools:**

- `apps/web/src/mcp/helpers.ts` — return slugs, accept slug lookups
- `apps/web/src/mcp/manage-feeds.ts` — slug in responses
- `apps/web/src/mcp/manage-articles.ts` — slug in responses

**Backfill:**

- `packages/scripts/src/backfill-slugs.ts`
- `packages/scripts/package.json` — add script entry + `@repo/shared` dependency
